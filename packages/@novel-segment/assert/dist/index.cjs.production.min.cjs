"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var e=require("util"),t=require("assert");function n(t={}){var n,r;return null!==(n=t)&&void 0!==n||(t={}),{...t,inspectFn:null!==(r=t.inspectFn)&&void 0!==r?r:e.inspect}}function r(e,r,i={}){let o=null;const{inspectFn:l,firstOne:u}=n(i);let c=r.every((function(t,n,r){let i=-1,l=o;if(null==o&&(o=-1),Array.isArray(t)?u?t.some((function(t){let n=e.indexOf(t,l);if(n>-1&&n>o)return i=n,!0})):i=t.reduce((function(t,n){let r=e.indexOf(n,l);return r>-1&&r>o?-1==t?r:Math.min(r,t):t}),-1):i=e.indexOf(t,l),i>-1&&i>o)return o=i,!0}));return-1===o&&(c=!1),!c&&t.fail(`expected ${l(e)} to have includes ordered members ${l(r)}`),c}exports._handleLazyMatchOptions=n,exports.lazyMatch=r,exports.lazyMatch002=function(e,i,o={}){let l;o=n(o);for(let t of i)try{if(l=r(e,t,o),l)break}catch(e){}!l&&t.fail(`expected ${o.inspectFn(e)} to have includes one of ordered members in ${o.inspectFn(i)}`)},exports.lazyMatchNot=function(e,r,i={}){let o=null;const{inspectFn:l}=n(i);let u=r.every((function(t,n,r){let l=-1,u=o;return null==o&&(o=-1),Array.isArray(t)?i.firstOne?t.some((function(t){let n=e.indexOf(t,u);if(n>-1&&n>o)return l=n,!0})):l=t.reduce((function(t,n){let r=e.indexOf(n,u);return r>-1&&r>o?-1==t?r:Math.min(r,t):t}),-1):l=e.indexOf(t,u),!(l>-1&&(o=l,1))}));return-1===o&&(u=!0),!u&&t.fail(`expected ${l(e)} should not have includes ordered members ${l(r)}`),u},exports.lazyMatchSynonym001=function(e,r,i={}){let o,l;const{inspectFn:u}=n(i);o=r.every((function(n){let r=l;null==l&&(l=-1);let i=-1;if(Array.isArray(n)?n.some((t=>{let o=e.indexOf(t,r);if(o>-1)return i=o,n=t,!0})):i=e.indexOf(n,r),i>-1&&i>=l)return l=i+n.length,!0;l>-1&&t.fail(`expected ${u(e)} to have have ${u(n)} on index > ${l}, but got ${i}`)})),-1===l&&(o=!1),!o&&t.fail(`expected ${u(e)} to have index of ordered members in ${u(r)}`)},exports.lazyMatchSynonym001Not=function(e,r,i={}){let o;const{inspectFn:l}=n(i);r.every((function(n){let r=o;null==o&&(o=-1);let i=-1;if(Array.isArray(n)?n.some((t=>{let o=e.indexOf(t,r);if(o>-1)return i=o,n=t,!0})):i=e.indexOf(n,r),i>-1&&i>o)return t.fail(`expected ${l(e)} to not have ${l(n)} on index > ${o}, but got ${i}`),!0;o++}))};
//# sourceMappingURL=index.cjs.production.min.cjs.map
